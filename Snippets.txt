// These might be inefficient but get the job done with the basics

// Get nth vaue of Lists/Sequences without nth

(fn foo [m n]
  (if (> n 0)
  (foo (rest m) (- n 1))
  (first m)
  )
)

// Count of a sequence given a sequence without count

#((partial (fn foo [mycount m]
  (if (not= (rest m) '())
  (foo (+ mycount 1) (rest m))
  mycount
)
) 1) %)


// Return sum of sequence

(fn [s] (reduce #(+ %1 %2) s))

// Return Odd numbers

(fn [s] (filter #(= (rem % 2) 1) s))


// Return Max value of variable input of values

(fn [& a] (reduce #(if(> %1 %2) %1 %2) a))

// Return only Capital parts from a given string

#(apply str (re-seq #"[A-Z]" %))

// Duplicate each element of an input sequence

(fn [s] (reduce #(conj %1 %2 %2) [] s))


// Remove duplicates in a sequence or string

(fn [s]
(reduce #(if (not= (last %1) %2) (conj %1 %2) %1) [] s)
)


// Implementing range function but lazily

(fn foo [n omega] 
  (lazy-seq 
   (if (< n omega)
    (cons n (foo (inc n) omega))  
)))

// Return factorial of a value

(fn foo [n]  
   (if (> n 1)
    (* n (foo (dec n)))
    n
))


// Function which takes two sequences and returns the first item from each, then the second item from each, then the third, etc.

(fn foo [s1 s2]
(if (and (> (count s1) 0) (> (count s2) 0))
( cons (first s1) (cons (first s2)  (foo (rest s1) (rest s2)))
 ))
)

// replicates each element of a sequence a variable number of times

(fn foo [s n]
(if (> (count s) 0)
(concat (for [i (range n)] (first s)) (foo (rest s) n))
s
)
)

// Split a sequence into two with first part containing n number of elements

(fn foo [n s]
(let [[a & b] (partition-all n s)] [a (apply concat b)])
)


// Take two sequences and create a map from them

(fn foo [s1 s2]
(if (and (> (count s1) 0) (> (count s2) 0))
(conj (hash-map (first s1) (first s2))  (foo (rest s1) (rest s2)))
)
)

// GCD of two numbers 

#(reduce max (
              (fn [a b]
				(for [i (range (max a b))
              		  :when (and (not= i 0) (= (mod a i)0) (= (mod b i) 0))
              		 ]
					i)) %1 %2))

// Take N and return a function that does a power n of any input

(fn [n]
#(int (Math/pow % n))
)
